use borsh::BorshSerialize;
use exploit::{
    LocalEnvBuilder,
    state::{ Farm, FARM_FEE, FarmInstruction },
    AccountConfig
};

use solana_program::{
    native_token::{
        sol_to_lamports,
        lamports_to_sol
    },
    instruction::{
        AccountMeta,
        Instruction
    }, pubkey::PubkeyError
};

use solana_sdk::{
    account::Account,
    program_pack::Pack
};

use solana_program_test::tokio;

use solana_sdk::{
    signature::{read_keypair_file, Keypair, Signer},
    pubkey::Pubkey
};
use spl_token::state::Account as TokenAccount;

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    /////////////////////////////
    // 
    //    Initial configuration
    // 
    /////////////////////////////
    
    // Enter path to program
    let program_path = "./"; 
    let victim_program = std::fs::read(program_path).expect("Error: Reading program file");
    let victim = Keypair::new();
    let attacker = Keypair::new();


    // Prepare a SPLToken if needed
    let spl_mint_auhority = Keypair::new();
    let spl_mint_key = Keypair::new();
    
    let mut sol_env = LocalEnvBuilder::new()
        .add_account(
            victim.pubkey(),
            AccountConfig {
                lamports: Some(sol_to_lamports(100_000.0)),
                ..Default::default()
            },
        )
        .add_program(victim.pubkey(), victim_program)
        .add_account(
            attacker.pubkey(),
            AccountConfig {
                lamports: Some(sol_to_lamports(10.0)),
                ..Default::default()
            },
        )
        .build().await;

    // create token
    sol_env.create_token_mint(&spl_mint_key, spl_mint_auhority.pubkey(), None, 6).await?;
    
    // mint to attacker
    let attacker_ata = sol_env.create_associated_token_account(attacker.pubkey(), spl_mint_key.pubkey()).await?;
    sol_env.mint_tokens(spl_mint_key.pubkey(), &spl_mint_auhority, attacker_ata, 5_000_000).await?;

    // mint to victim
    let victim_ata = sol_env.create_associated_token_account(victim.pubkey(), spl_mint_key.pubkey()).await?;
    sol_env.mint_tokens(spl_mint_key.pubkey(), &spl_mint_auhority, victim_ata, 95_000_000).await?;

    
    // Get initial SPLToken balance
    let attacker_spl: Account = sol_env.account(attacker_ata).await?;
    let attacker_ata_content = TokenAccount::unpack(attacker_spl.data.as_ref()).expect("Error: Deserializing ATA");
    let victim_spl: Account = sol_env.account(victim_ata).await?;
    let victim_ata_content = TokenAccount::unpack(victim_spl.data.as_ref()).expect("Error: Deserializing ATA");

    // Display balances
    println!("\n\nAttacker SOL Balance before exploit: {}", lamports_to_sol(sol_env.account(attacker.pubkey()).await
        .expect("Error: reading balance").lamports));
    println!("Victim SOL Balance before exploit: {}\n\n", lamports_to_sol(sol_env.account(victim.pubkey()).await
        .expect("Error: reading balance").lamports));
    println!("\n\nAttacker USDC Balance before exploit: {}", attacker_ata_content.amount);
    println!("Victim USDC Balance before exploit: {}\n\n", victim_ata_content.amount);
    println!("Victim USDC ATA owner before exploit: {}\n\n", victim_ata_content.owner);



    /////////////////////////////
    // 
    //    Exploit preparation
    // 
    /////////////////////////////
    
    // Write your exploit here


    /////////////////////////////
    // 
    //    Verification
    // 
    /////////////////////////////

    // Display balances after exploit

    let attacker_spl: Account = sol_env.account(attacker_ata).await?;
    let attacker_ata_content = TokenAccount::unpack(attacker_spl.data.as_ref()).expect("Error: Deserializing ATA");

    let victim_spl: Account = sol_env.account(victim_ata).await?;
    let victim_ata_content = TokenAccount::unpack(victim_spl.data.as_ref()).expect("Error: Deserializing ATA");

    println!("\n\nAttacker SOL Balance after exploit: {}", lamports_to_sol(sol_env.account(attacker.pubkey()).await
        .expect("Error: reading balance").lamports));
    println!("Victim SOL Balance after exploit: {}\n\n", lamports_to_sol(sol_env.account(victim.pubkey()).await
        .expect("Error: reading balance").lamports));
    println!("\n\nAttacker USDC Balance after exploit: {}", attacker_ata_content.amount);
    println!("Victim USDC Balance after exploit: {}\n\n", victim_ata_content.amount);

    Ok(())


}

